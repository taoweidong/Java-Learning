package com.leetcode;

import java.util.HashMap;
import java.util.Map;

/**
 * 924. 尽量减少恶意软件的传播
 */
public class LeetCode_924_MinMalwareSpread {
    public static void main(String[] args) {
        // int[][] graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        // int[] initial = {0, 1};

        int[][] graph = {{1, 0, 0, 0, 0, 0}, {0, 1, 1, 0, 0, 0}, {0, 1, 1, 0, 0, 0}, {0, 0, 0, 1, 1, 1},
            {0, 0, 0, 1, 1, 1}, {0, 0, 0, 1, 1, 1}};
        int[] initial = {2, 3};
        System.out.println(new LeetCode_924_MinMalwareSpread().minMalwareSpread(graph, initial));

    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int size = graph.length;
        // 初始化
        UfMalwareSpread ufMalwareSpread = new UfMalwareSpread(size);
        for (int i = 0; i < graph.length; i++) {
            for (int j = i + 1; j < graph[0].length; j++) {
                if (graph[i][j] == 1) {
                    ufMalwareSpread.union(i, j);
                }
            }
        }

        // 处理每个连通全中的中毒个数
        int[] badParent = new int[size];
        for (int node : initial) {
            badParent[ufMalwareSpread.find(node)]++;
        }

        // System.out.println(Arrays.toString(badParent));

        // 寻找最优待删除节点
        // Arrays.sort(initial);

        // initial中各个节点涉及到的连通分子量总和，去掉某一个后被感染的连通分量总和最小，其实就是找到某一个所在连通分量最大的那个
        int result = -1;
        int maxSize = -1;
        for (int node : initial) {
            int root = ufMalwareSpread.find(node);
            // 一个朋友圈超过两个的不进行处理，因为会相互感染，没有处理的意义
            if (badParent[root] == 1) {
                // 感染节点存在涉及到的节点个数
                int rootSize = ufMalwareSpread.getSize(root);
                // 说明是单独的一个
                if (rootSize > maxSize) {
                    maxSize = rootSize;
                    result = node;
                } else if (rootSize == maxSize && node < result) {
                    maxSize = rootSize;
                    result = node;
                }
            }

        }

        if (result == -1) {
            result = Integer.MAX_VALUE;
            for (int node : initial) {
                result = Math.min(result, node);
            }
        }
        return result;
    }
}

class UfMalwareSpread {

    private int[] parent;

    private Map<Integer, Integer> sizeMap;

    public UfMalwareSpread(int size) {
        parent = new int[size];
        sizeMap = new HashMap(size);
        for (int i = 0; i < size; i++) {
            parent[i] = i;
            sizeMap.put(i, 1);
        }

    }

    /**
     * 找根节点
     *
     * @param index
     * @return
     */
    public int find(int index) {
        // while (index != parent[index]) {
        // // 此处压缩路径
        // // parent[index] = parent[parent[index]];
        // index = parent[index];
        // }
        // return index;

        if (parent[index] != index) {
            parent[index] = find(parent[index]);
        }
        return parent[index];
    }

    public void union(int left, int right) {
        int leftRoot = find(left);
        int rightRoot = find(right);
        if (leftRoot == rightRoot) {
            // 已经相连了，没有必要再进行合并了
            return;
        }
        // 把两个节点链接起来
        parent[leftRoot] = rightRoot;
        // size--;
        sizeMap.put(rightRoot, sizeMap.getOrDefault(leftRoot, 0) + 1);

    }

    public int getSize(int index) {
        return sizeMap.getOrDefault(find(index), 0);
    }
}